# Trie - 字典树实现

Trie（发音为"try"）是一种高效的字符串查找树，也称为前缀树或字典树。这个实现提供了一个通用的 Trie 数据结构，支持字符串的插入和查询操作。

## 特性

- 支持任意字符串的插入和查询
- 使用哈希表（unordered_map）存储子节点，提供 O(1) 的查找效率
- 支持重复字符串的计数
- 自动内存管理，防止内存泄漏
- 时间复杂度：插入和查询均为 O(m)，其中 m 为字符串长度

## 主要接口

### 构造函数
```cpp
Trie();  // 创建一个空的 Trie
```

### 基本操作
```cpp
void insert(const string& str);  // 插入字符串
int query(const string& str);    // 查询字符串出现次数
```

## 使用示例

```cpp
#include "Trie.hpp"

int main() {
    Trie trie;
    
    // 插入字符串
    trie.insert("hello");
    trie.insert("hello");  // 插入重复字符串
    trie.insert("world");
    
    // 查询字符串出现次数
    cout << trie.query("hello");  // 输出：2
    cout << trie.query("world");  // 输出：1
    cout << trie.query("hi");     // 输出：0（不存在的字符串）
    
    return 0;
}
```

## 实现细节

### 节点结构
```cpp
struct TreeNode {
    unordered_map<char, TreeNode*> children;  // 子节点映射表
    int count;                                // 以该节点结尾的字符串数量
};
```

### 主要算法

1. **插入操作**
   - 从根节点开始，逐个字符遍历待插入的字符串
   - 对于每个字符，如果对应的子节点不存在，则创建新节点
   - 移动到子节点，继续处理下一个字符
   - 在最后一个字符对应的节点增加计数

2. **查询操作**
   - 从根节点开始，逐个字符遍历待查询的字符串
   - 如果任何一个字符没有对应的子节点，返回0
   - 返回最后一个节点的计数值

3. **内存管理**
   - 使用递归方式在析构函数中释放所有节点
   - 确保不会发生内存泄漏

## 性能分析

- **空间复杂度**：O(T)，其中 T 为所有插入字符串的字符总数
- **时间复杂度**：
  - 插入：O(m)，m 为待插入字符串的长度
  - 查询：O(m)，m 为待查询字符串的长度

## 应用场景

1. 自动补全和拼写检查
2. 字符串集合的高效存储和查询
3. 前缀匹配
4. 字典实现
5. IP路由表查找

## 注意事项

1. 对于大规模数据，注意内存使用
2. 字符串为空时的特殊处理
3. 区分大小写处理
4. 注意字符编码问题
